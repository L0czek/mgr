\cleardoublepage
\section{Summary} \label{chap:summ}
The topic of fuzz testing inside an embedded operating system is very complex and requires connecting together many components. In this thesis I have shown how such setup can be established using open-source components such as \textit{AFLplusplus} \textit{fuzzer} and \textit{QEMU} system emulator. They were modified to fit the task of \textit{fuzzing} operating systems instead of simple applications. Additionally, a module conducting test case decoding was designed to enable structured \textit{fuzzing}. Thanks to this the created solution can be applied to arbitrary target consisting of a set of functions and structs. Naturally, since this thesis aims at systems created using \textit{Rust} programming language, the target needs to expose interface in \textit{Rust}. To achieve the support of such interfaces a special declarative language was designed. It allows for describing the target interface to the \textit{fuzzer} so that the compiler automatically generates the tests code which can call functions, create and manage objects. This module can be configured by the test case generated by \textit{AFLplusplus} \textit{fuzzer} in runtime by interpreting the raw bytes sequence provided by the genetic algorithm inside \texti{AFL}.

The setup was evaluated by comparing the speed and effectiveness of \textit{fuzzing} a specially crafted services running under \textit{OPTEE} operating system. The experiments were crafted to show how different design choices impact the \textit{fuzzing} result. First and foremost, the issue of saving and restoring the state of the virtual machine during \textit{fuzzing} was investigated. Naturally, the first choice is whether to even implement the state preserving mechanism into \textit{QEMU}, as it doesn't come without cons. From the experiments that is heavily impacts the \textit{fuzzing} speed by adding significant delays due to the need to basically duplicate copy the memory and virtual processor state and then write it back. This slow down isn't constant and may vary on the target's architecture, for example small system employing only real time cores with limited resources will require far less time when compared to a system running \textit{Linux} operating system with several giga bytes of RAM memory. However, preserving the initial state of the target operating system has one big advantage. It significantly increases the reproducibility of the registered crashes as there are no changes done to the system accumulating across test cases. <@ TODO 2 wersje restore > 

Next, the test case decoder was evaluated to see if it improves the exploration of the target leading to registering more crashes. The first test compared the usage of the test case decoder to plugging the test case bytes directly to the target. Of course, the \textit{fuzzed} services were designed in a way to allow passing in raw data. <@ TODO result @> The last test checked how seeding the \textit{fuzzer's} corpus with valuable data affects the testing process. To accomplish this I created a utility which allows for tracing unit tests and generating the binary test cases. <@ TODO wyniki @>

In conclusion, this thesis presents a robust setup allowing for fuzz testing arbitrary services on embedded platforms. I show how this system can be assembled from modified open-source components and repurposed to the task of \textit{fuzzing} operating system. I evaluated many design choices that can be made during the construction of a similar project to chose is best suited for the presented task. Unfortunately, as the described approach relies on heuristics and genetic algorithms it is not guaranteed to be the perfect solution for any case. Nonetheless, the discussed method provides ideas that can be useful when the target doesn't support any other \textit{fuzzing} method and just exposes some interface. Additionally, as the more and more embedded system are deployed this field of research will gain importance.