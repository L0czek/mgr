\cleardoublepage
\section{Test environment design} \label{chap:envir}

% TODO wywaliÄ‡?
%\subsection{Requirements and design choices}
%The fuzzing target will be a set of classes with member functions which compose the interface of a secure service. Of course, in Rust there are no classes as it has only structs and implementations, but for simplicity I will refer to struct with member functions as classes. The fuzzer will create objects of these classes and then proceed with fuzzing their member functions. The use of generics and explicit lifetime parameters is not supported to simplify the design. The target will be running as a trusted application inside \textit{OPTEE OS}. This program will be compiled with all necessary utilities to communicate with the fuzzer through \textit{QEMU}.

\subsection{Chapter content}

This chapter focuses on exploring the inner workings of the test case decoder mentioned in chapter \ref{chap:why}. It can be divided into a couple of submodules like seen in figure \ref{fig:cntdiag}. The main task of this module is to interpret test cases from \textit{AFLplusplus} fuzzer and call the secure services based on the received data. This is accomplished by the following steps:
\begin{enumerate}
    \item It begins with the description which tells the fuzzer how to use the interface the target provides. This step is called \textit{API description} and utilizes a specially created language. The design and some examples of this domain specific language are provided in section \ref{sec:lang}.
    \item Next, the target description is fed to the compiler which generates the so-called \textit{executor}. This is done by implementing a special macro which takes as arguments the source code of the special language end emits \textit{Rust} code. It is described in section \ref{sec:compiler}.
    \item Finally, the generated \textit{executor} module communicates with the \textit{QEMU} to fetch the test cases and then interprets it using the compiled code. During execution of the test case this module call directly the target which is represented by the \textit{Secure services} module. The actual algorithm which controls the fuzzing process is walked through in section \ref{sec:testcase}.
\end{enumerate}
The second task is all about seeding the \textit{AFLplusplus} corpus using unit tests of the target. Since the compiler is used to generate the test case interpreter it can also be used to go the opposite way and create test cases from function calls. This process works as follows:
\begin{enumerate}
    \item The compiler uses the target description to generate the test case reverser. In detail generated \textit{Rust} source code contains an augmented replica of the target that acts as a proxy and traces the function parameters to assemble the test case. The details of this process are described in section \ref{sec:testint}.
    \item The module containing the unit tests is modified to used the generated replica to seamlessly introduce instrumentation. After each unit test the generated sequence of bytes is returned to \textit{QEMU} to be saved in the corpus folder of \textit{AFLplusplus}.
\end{enumerate}
Similarly, like in chapter \ref{chap:why} the background color are used to distinguish open source modules from the custom ones, created by me. Just as a quick reminder the colors mean the following:
\begin{itemize}
    \item \colorbox{green!30}{light green} - marks an open source project which was only slightly modified or adapted,
    \item \colorbox{orange!30}{orange} - marks components which were fully created by me,
    \item \colorbox{yellow!30}{yellow} - marks components whose modification were required,
    \item \colorbox{green!60}{green} - marks an unmodified open source component.
\end{itemize}


\tikzstyle{opensource} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!30]
\tikzstyle{custom} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=orange!30]
\tikzstyle{opensourcemod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!60]
\tikzstyle{custommod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=orange!60, text width=2cm]
\tikzstyle{modifiedmod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=yellow!30]
\tikzstyle{host} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=brown!30]

\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzstyle{darrow} = [thick,<->,>=stealth]

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \node (api) [custommod] { API description };
        \node (compiler) [custommod, right of=api, xshift=3cm] { Compiler };
        \node (executor) [custommod, right of=compiler, xshift=3cm] { Executor };
        \node (rev) [custommod, below of=compiler, yshift=-1cm] { Test case reverser };
        \node (unittests) [custommod, below of=api, yshift=-1cm] { API unit tests };
        
        \begin{pgfonlayer}{background2}
            \node (tcdecoder) [custom, fit={(api) (compiler) (executor) (rev) (unittests)}, label={Test case decoder}, text width=12cm, text height=4cm] {};
        \end{pgfonlayer}

        \node (services) [custommod, right of=executor, xshift=3cm] { Secure services };
        \node (kernel) [opensourcemod, above of=compiler, yshift=1.5cm, text width=15.5cm, xshift=1.75cm] { OPTEE OS kernel };]

        \begin{pgfonlayer}{background1}
            \node (opteeos) [opensource, fit={(kernel) (tcdecoder) (services)}, label={ OPTEE OS }] {};]
        \end{pgfonlayer}


        \node (fuzzint) [custommod, below of=rev, yshift=-1.5cm] { Fuzzer integration };

        \begin{pgfonlayer}{background0}
            \node (qemu) [opensource, fit={(opteeos) (fuzzint)}, label={ QEMU }, text height=9.2cm] {};
        \end{pgfonlayer}
        
        \draw [arrow] (api) -- (compiler);
        \draw [arrow] (unittests) -- (rev);
        \draw [arrow] (compiler) -- (rev);
        \draw [arrow] (compiler) -- (executor);
        \draw [arrow] (rev) -- (fuzzint);
        \draw [darrow] (executor) -- (services);
        \draw [arrow] (fuzzint) -| (executor); 
        \draw [darrow] (services) --++ (0cm, 2cm);
    \end{tikzpicture}
    \caption{Modules diagram}
    \label{fig:cntdiag}
\end{figure}

\subsection{Designing the API description language}
Let us assume the target API uses simple types and objects passed by value or reference. For this reason, I didn't implement support for generics and lifetime syntax. The mentioned lifetime is a special feature of the \textit{Rust} language. It was designed to allow the programmer to bind the lifetime of different entities together. For clarity, these extensions' syntax is similar to \textit{C++} templates. It features special parameters that allow type specialization based on:
\begin{enumerate}
    \item other types denoted as labels, for example \textit{T},
    \item constant values, for example \textit{const N},
    \item lifetime symbol which allows for explicitly connecting lifetimes of different objects, for example \textit{'a}.
\end{enumerate}
Typically, such syntax becomes handy in a situation where one field of a struct is a reference. In such cases, \textit{Rust} compiler requires the programmer to specify explicitly the lifetime of the object and the reference. Naturally, in most cases the reference will live as long as the object, so their lifetime can be denoted by the same symbol as shown in listing \ref{lst:generics}. There we can see a definition of struct \textit{Buffer}, which has an explicit lifetime \textit{'a} and depends on some type \textit{T}. This struct holds one item which is a reference to an array of \textit{T} type elements which also has an explicit lifetime \textit{'a}. This tells the compiler that the reference will live as long as the object holding it. Removing this language features described above forbids the generated code to use compile time polymorphism, leaving the runtime one available. However, the \textit{Rust} compiler has the ability to perform type deduction based on how the object is used. This allows for omitting some type specification in simple cases such as declaring an array if the code adds an element of known type.

To call a function, we need to describe how to construct its arguments. Therefore, the designed language needs to offer primitives enabling easy construction of simple types such as numbers or text literals. Each of these arguments can be instantiated before the function call and destroyed after, so that all Rust's lifetime rules are preserved. What is more complicated is invoking classes' member functions. Here, the object itself needs to be constructed beside the parameters. This can be easily done, as an object constructor relies sole on the function arguments. All of this discussion leaves us with a simple functional language with a couple of primitives defined.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Generic and lifetime parameter exmaple},label={lst:generics}]
struct Buffer<'a, T> {
    slice: &'a [T]
}
\end{lstlisting}
\end{minipage}

\subsubsection{Designing the fuzzing process} \label{sec:testcase}
Overall, the fuzzing process consists of several steps repeated in a loop:
\begin{enumerate}
    \item fetching the test case from the hypervisor,
    \item running the test case using the system calls interpreter,
    \item reporting back to the hypervisor if anything has happened,
    \item preparing to run the next test.
\end{enumerate}
The communication with the hypervisor was described in the previous chapter. The next thing that needs to be discussed is the test case decoding algorithm. Its simplified version is presented in algorithm \ref{alg:syscall_decode}. The description uses several terms and entities which have the following meaning:
\begin{itemize}
    \item $i$ - is the iterator indexing the test case received from the \textit{fuzzer},
    \item $API$ - this refers to the class which will be fuzzed,
    \item $APIs$ - this is the array of all classes which where described in the special language,
    \item $testcase$ - as the name suggest this is the received test case which is stored as array of bytes,
    \item $API.constructor$ - it refers to all the described function which create an object of a specific class,
    \item $API.functions$ - this refers to all member functions of the class.
\end{itemize}
This pseudocode is invoked in a loop until the entire test case is exhausted. In the first step, the class from which the fuzzing will begin is chosen. The selection process is based on drawing uniformly from a pool of options. The fairness of the lottery is ensured by taking a byte from the test case, interpreting it as a natural number, and then limiting the range of values by performing a modulo operation. Of course, when the number of choices are greater than 255 more bytes needs to be used. In my case, this was always enough, as rarely the \textit{fuzzer} would need to choose from more than a couple of values. After, the first target class is chosen, the \textit{fuzzer} proceeds with selecting a constructor which will be used to create the object. Naturally, there may be many ways to construct an object of some type, therefore the constructor is also drawn just like the target in the first place. Next, the chosen function is called, and the return object is saved. When this is done, the fuzzer starts a loop which will call the member functions. This loop repeats until two conditions hold:
\begin{itemize}
    \item the end of the test case was not reached,
    \item the exit condition is not met.
\end{itemize}
The second special check is implemented to allow breaking the loop based on values in the test case. In detail, the fuzzer continues the loop until the drawn boolean stays true. This might look unnecessary, but is actually essential to support the ability to reverse the fuzzing process described later in this chapter. Inside this loop, the fuzzer selects and calls the class member functions. The selection mechanism again conducts a uniform draw like established above. In the end, the object is returned to the caller. This is necessary to support the situation where a function from one class takes an object of the other as argument. In such cases, the fuzzing of the selected function is interrupted, and this algorithm is recursively run against the dependency. Finally, after all exit conditions are met, the hypervisor is informed of the fuzzing result.

\begin{algorithm}
    \begin{algorithmic}
        \State $i \gets 0$
        \State $API \gets APIs[testcase[i++] \mod length(APIs)]$
        \State $constructor \gets API.constructors[testcase[i++] \mod length(API.constructors)]$
        \State $obj, i \gets constructor(testcase, i)$
        \While{$testcase[i++] \mod 2 \&\& i < length(testcase)$}
            \State $function \gets API.functions[testcase[i++] \mod length(API.functions)]$
            \State $i \gets obj.function(testcase, i)$
        \EndWhile
        \State \Return $obj$
    \end{algorithmic}
    \caption{System calls decoding algorithm}
    \label{alg:syscall_decode}
\end{algorithm}

\paragraph{Illustration of the algorithm}
An example of a target API is presented in listing \ref{lst:extarget}. It consists of two classes providing some basic security features. The first is a cryptographic key storage utility. It can be seen in its definition that it holds the keys as an anonymous field of a byte array type. In \textit{Rust} a \textit{Vec} is a similar container to \textit{std::vector} from \textit{C++}. These class defines two functions:
\begin{enumerate}
    \item a constructor named \textit{new} which takes a key as a slice of bytes,
    \item a function named \textit{wrap} which encrypts a key using another that is provided as an argument by a reference to another \textit{Key} object.
\end{enumerate}
The latter class implements the AES cipher. Similarly, as the \textit{Key} class, this one also has one anonymous field storing the cryptographic key. It defines three functions which go as follows:
\begin{enumerate}
    \item a constructor named \textit{new} which takes an object of the described above \textit{Key} class,
    \item an \textit{encrypt} function which takes plaintext as a slice of bytes, cipher mode as an \textit{enum} and returns the ciphertext as a byte array,
    \item a \textit{decrypt} function that uses the same types of arguments as the \textit{decrypt} and converts from ciphertext to plaintext.
\end{enumerate}
The mentioned cipher mode is defined as an enumeration with two values for the \textit{ECB} (short for \textit{Electronic Code Book}) and the \textit{CBC} (short for \textit{Cipher Block Chaining}). The fuzzer can take 2 routes here. It can start with selecting the Key class or the \textit{Aes} one. Selecting the former will limit the fuzzing scope to only the \textit{Key} class, as its functions doesn't rely on other entities. However, this is not true for the cipher class. The constructor of \textit{Aes} class takes a key, which requires creating it first. In general, the fuzzer needs to support cross-references between classes.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Target API exmaple},label={lst:extarget}]
struct Key(Vec<u8>);

impl Key {
    pub fn new(key: &[u8]) -> Self;
    pub fn wrap(&self, other: &Key);
}

struct Aes(Key);

enum AesMode {
    ECB,
    CBC
}

impl Aes {
    pub fn new(key: Key) -> Self;
    pub fn encrypt(&self, data: &[u8], AesMode: mode) -> Vec<u8>;
    pub fn decrypt(&self, data: &[u8], AesMode: mode) -> Vec<u8>;
}
\end{lstlisting}
\end{minipage}

The simplified illustration of the fuzzer action can be seen in \ref{fig:fuzzscenario}. It shows that the execution has two main branches. The one starting with \textit{Key} class and the other with \textit{Aes}. As discussed before, the \textit{Key} class doesn't require any other entity, therefore it has far less possible options. On the other hand, even though the \textit{Aes} path has been entered the fuzzer goes back to fuzzing \textit{Key} class as its object is required for the constructor of the cipher. One might think that fuzzing the \textit{Key} class just to provide an object is unnecessary, as just calling the constructor will provide the required object. However, calling member functions on an object might modify the internal state of such object. Therefore, invoking just the constructor will limit the exploration abilities of the fuzzer. This can then lead to limited ability to find sophisticated bugs that require many conditions to trigger. Then the fuzzer chooses and calls appropriate member functions.

\tikzstyle{start} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!60]
\tikzstyle{api} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!30]
\tikzstyle{call} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=yellow!30]
\tikzstyle{end} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}[h!]
    \centering

    \scalebox{.75}{%
        \begin{tikzpicture}
            \node (start) [start] {Choose API to fuzz};
            \node (key) [api, below of=start, yshift=-1cm] { Choose to fuzz \textit{Key} API };
            \node (aes) [api, right of=key, xshift=5cm] { Choose to fuzz \textit{Aes} API };
    
            \node (keyctor) [call, below of=key, yshift=-1cm] { Call Key::new(...) };
            \node (wrap) [call, below of=keyctor, yshift=-1cm] { Call Key::wrap(constructed key) };
            \node (end1) [start,  below of=wrap, yshift=-1cm] { End };
    
            \node (keyctor2) [call, below of=aes, yshift=-1cm] { Call Key::new(...) };        
            \node (keymember) [call, below of=keyctor2, yshift=-1cm, text width=3cm] { Call some member functions on key };
            \node (aesctor) [call, below of=keymember, yshift=-1cm] { Call Aes::new(constructed key) };
            \node (dec) [decision, below of=aesctor, yshift=-3cm, text width=3cm, xshift=0cm] { Choose member function to call };
            \node (encrypt) [call, below of=dec, left of=dec, yshift=-3cm, xshift=-4cm] { Call Aes::encrypt(aes, ...) };
            \node (decrypt) [call, below of=dec, left of=dec, yshift=-3cm, xshift=1cm] { Call Aes::decrypt(aes, ...) };
            \node (end2) [start, below of=decrypt, yshift=-1cm] { End };
            
            \draw [arrow] (start) -- (key); 
            \draw [arrow] (start) -| (aes);
            \draw [arrow] (key) -- (keyctor);
            \draw [arrow] (keyctor) -- (wrap);
            \draw [arrow] (wrap) -- (end1);
            \draw [arrow] (aes) -- (keyctor2);
            \draw [arrow] (keyctor2) -- (keymember);
            \draw [arrow] (keymember) -- (aesctor);
            \draw [arrow] (aesctor) -- (dec);
            \draw [arrow] (dec) -| (encrypt);
            \draw [arrow] (dec) -- (decrypt);
            \draw [arrow] (encrypt) |- (end2);
            \draw [arrow] (decrypt) -- (end2);
        \end{tikzpicture}
    }
    
    \caption{Possible fuzzing scenario}
    \label{fig:fuzzscenario}
\end{figure}

\subsubsection{Structure-aware fuzzing}
Many targets like the discussed operating systems or any services exposing a function like interface require a structured data format. Here these formats refer to objects being supplied as function parameters and objects to call member function on. Currently, the \textit{Rust} community designed in \cite{rustfuzzbook} a special library allowing to construct objects from random bytes. It requires the use of a special macro that generates the deserialization code based on the structure content. This can be a great tool aiding the creation of objects, but has a couple of disadvantages. First, it works seamlessly, which can be a great feature but also doesn't allow for more control in how the objects are created. As a result, small changes in input sequence might lead to large changes in resulting objects. This can have a destabilizing effect on the genetic fuzzing algorithm. Furthermore, when fuzzing an interface with a hidden state, applying operations on previously created objects can be beneficial. By hidden state I mean that part of it is stored outside the object itself. The \textit{file descriptor} from \textit{Linux} operating system is a good example of such object, as it just points to a structure stored inside the kernel. 

The application of the \textit{Arbitrary} is shown in listing \ref{lst:arb_crate}. There the \textit{Arbitrary} crate will be implemented for the \textit{Friend} \textit{enum} which has two options with each of them containing an associated object. The macro will take care of encoding different options and their types, as long as all types that the \textit{Friend} \textit{enum} relies on also implement \textit{Arbitrary} crate. Naturally, since \textit{usize} and \textit{String} types are standard types taken from Rust's standard library, the \textit{Arbitrary} crate is already implemented for them. The next sections explore another way of constructing objects from byte sequences that can give more control on object creation.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Rust,caption={Example of \textit{Arbitrary} crate usage},label={lst:arb_crate}]
#[derive(Arbitrary)]:
pub enum Friend {
    Buddy { name: String },
    Pal { age: usize },
} 
\end{lstlisting} 
\end{minipage}

The inner working of this library are quite simple. It defines a custom deserialization algorithm for each of the standard types. For clarity, in the \textit{Friend} \textit{enum} example the types can be handled as follows:
\begin{itemize}
    \item the \textit{usize} implements the \textit{from\_le\_bytes} function which can be directly, for example \textit{usize::from\_le\_bytes([1, 0, 0, 0, 0, 0, 0, 0])} returns an \textit{usize} with the value of $1$,
    \item the \textit{String} type is just a collection of characters, so as every iterable entity this can be serialized as its length which is a number and then followed by the characters,
    \item finally the \textit{enum} itself can be treated as a union of different entities which are distinguished by an assigned number which is unique to each \textit{enum}'s option, after the identifier is saved, the rest of the \textit{enum} can be treated as a \textit{union} from \textit{C} language which means that we can just serialize the object associated with the \textit{enum} options.
\end{itemize}

\subsubsection{Design of the target description language} \label{sec:lang}
In the big picture, the API description is a list of classes, where every entry consists of two sets:
\begin{enumerate}
    \item the set of constructors, which tell the fuzzer how to construct the object,
    \item the set of member functions which can be called on the object.
\end{enumerate}
These sets store references to functions with description showing how to construct each argument. As already discussed, the language needs to provide several primitives to allow for instantiating parameters from test cases. This will vary based on the fuzzed target, as different APIs might require different types of arguments. To cover most common types of parameters, the language should implement the following primitives:
\begin{itemize}
    \item \textit{\#U8, \#U16, \#U32} - expressions allowing the creation of numbers,
    \item \textit{\#Slice(length)} - to take a slice of the test case of provided length and return as if it was an array, 
    \item \textit{\#Api(name)} - to specify a reference to another class in the target list,
    \item \textit{\#OneOf(option1, option2, ...)} - to draw at random an option from the provided list,
    \item \textit{\#Mod(a, b)} - performs module operation $a \mod b$,
    \item \textit{ref } - to take an immutable reference of the argument.
\end{itemize}
To summaries the design in a formal way I provided the grammar rules in \textit{EBNF} form in listing \ref{lst:grammar}. It contains all symbols that are used in the designed language except for \textit{RUST\_EXPRESSION}. I omitted the description for this symbol as it refers to the expression from \textit{Rust} language and is not part of my design.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Target description language grammar.},label={lst:grammar}]
LETTER = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" 
DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
IDENTIFIER = LETTER, { LETTER | DIGIT | "_" }

TARGET = "Target", "{", API, { ",", API } "}"
API = IDENTIFIER, "{", CTOR_LIST, FUNC_LIST, "}"
CTOR_LIST = "ctor", "{", CTOR_CALL_DESCRIPTION, {",", CALL_DESCRIPTION }, "}"
FUNC_LIST = "functions", "{", FUNC_CALL_DESCRIPTION?, { ",", CALL_DESCRIPTION }, "}"
CTOR_CALL_DESCRIPTION = PATH, "(", [ ARG ], { ",", ARG }, ")", "->", EXPR
FUNC_CALL_DESCRIPTION = IDENTIFIER, "(", [ ARG ], { ",", ARG }, ")", "->", EXPR
PATH_ELEMENT = IDENTIFIER | "super" | "crate"
PATH = PATH_ELEMENT, { "::", PATH_ELEMENT }
ARG = "#", MACRO | "ref" ARG | RUST_EXPRESSION
MACRO = "U8" | "U16" | "U32" | "Slice", "(", ARG, ")" | "Api", "(", IDENTIFIER, ")" |
        "OneOf", "(", RUST_EXPRESSION, { ",", RUST_EXPRESSION }, ")" |
        "Mod", "(", ARG, ",", ARG, ")"
\end{lstlisting}    
\end{minipage}

An example description of the discussed target can be seen in listing \ref{lst:desc}. It begins with the \textit{Target} keyword, which encapsulates the list of targets. Then follow the definitions of the classes. It begins with the class name, which is then followed by the list of constructors, denoted as \textit{ctor}, and member functions. As it can be seen, the \textit{Key} class has one constructor named \textit{Key::new}, whose argument is initialized by \textit{\#Slice(\#U8)}. This expression return a slice of the test case of length that is also taken from the test case. In detail, this expression will first read a byte and convert it to a natural number, as it is the parameter to the \textit{\#Slice()} macro. Then it will read the requested number of bytes and return it. This slice will be then passed as the argument to the constructor. The next entry in the \textit{Key} class defines one member function. The \textit{wrap} method takes a reference to another \textit{Key} object, which can be encoded in this language as \textit{ref \#Api(Key)}. Here, just as described earlier, the fuzzer will recursively begin fuzzing the \textit{Key} class to return the other object. After that, the \textit{ref} operator will take a reference and return it. This finishes the \textit{Key} class description, which is then followed by the specification of the \textit{Aes} one. Just like the former one, this also starts with the specification of the constructor which takes a key object, however this time the function takes ownership of the argument. As a result, its description is missing the \textit{ref} keyword when compared to the argument of the \textit{wrap} function. Then follow the member functions of \textit{Aes}. This time there are two entries, nevertheless their arguments are of the same types and differ just semantically. Therefore, only the entry for \textit{encrypt} function will be described. Its first argument is the plaintext passed as a byte slice, this is initialized just like the argument in \textit{Key} class constructor. Next, follows the cipher block mode selection. It is initialized by the \textit{\#OneOf(AesMode::ECB, AesMode::CBC)}, which will randomly draw one of the provided options. This completes the target description.

%\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={API description in the created language}, label={lst:desc}]
Target {
    Key {
        ctor {
            Key::new(#Slice(#U8))
        },
        functions {
            wrap(ref #Api(Key))
        }
    },
    Aes {
        ctor {
            Aes::new(#Api(Key))
        },
        functions {
            encrypt(#Slice(#U8), #OneOf(AesMode::ECB, AesMode::CBC)),
            decrypt(#Slice(#U8), #OneOf(AesMode::ECB, AesMode::CBC))
        }
    }
}    
\end{lstlisting}
%\end{minipage}

\paragraph{Implementation of the language primitives}
Each of the listed primitives can be implemented as an expression that transforms appropriate bytes from test case and yield the required entity. The \textit{\#U8, \#U16, \#U32} can be implemented by just taking some number of bytes from the test case, arranging them in, for example, little endian order and interpreting as a natural number. Next, the \textit{\#Slice(length)} macro takes the length and reads bytes from the test case and returns it as a reference. The \textit{\#Api(name)} primitive is a reference to another class in the target list. By itself it doesn't consume test case bytes as it just recursively start the fuzzing process again. This time, the step in the algorithm where the fuzzer chooses the class which begins the fuzzing process is omitted. Next, the \textit{\#OneOf(option1, option2)} is handled just like the other previously described lotteries. In detail, a byte is consumed and interpreted as a natural number. Naturally, the range of value is reduced to the number of given options by a modulo operation. In the generated code this operator is encoded as a sequence of conditional statements where each one handles one option. Last but not least, the \textit{ref} keyword emits a \textit{Rust}'s \textit{\&} operator and doesn't impact the test case processing.

To illustrate how the bytes in the test case are used, let us assume that the genetic algorithm inside \textit{AFLplusplus} generated a sequence of bytes seen in listing \ref{tc}. Naturally, these bytes aren't taken from a working example and are stated here just to demonstrate the point. Next, this test case can be coupled with its exemplary interpretation shown in listing \ref{tcdecoded}. For clarity, the corresponding parts between those listings are marked using the same background color. In detail the test case decodes as follows:
\begin{itemize}
    \item \colorbox{red!60}{A3} is used to select \textit{Aes} class,
    \item \colorbox{orange!30}{68} chooses the \textit{Aes} constructor, the \textit{Aes::new} method,
    \item \colorbox{blue!30}{62} selects the \textit{Key} class constructor,
    \item \colorbox{green!75}{0x08} tell how many bytes to read to the requested slice,
    \item \colorbox{green!60}{47 1F 88 91 0F 33 C6 28} is used as an argument for the Key's constructor,
    \item \colorbox{brown!30}{0xC1} doesn't break the member function fuzzing loop,
    \item \colorbox{purple!30}{0E} draws the member function to call on the created \textit{Aes} object,
    \item \colorbox{black!45}{0x08} tell how many bytes to read to the requested slice,
    \item \colorbox{black!30}{03 0F 74 4D BA 32 0D FF} is used as plaintext,
    \item \colorbox{yellow!60}{AA} selects the cipher block chaining mode,
    \item \colorbox{brown!60}{0xA0} breaks the member function fuzzing loop.
\end{itemize}
Of course, in the final setup these test cases are passed to compiled code for execution. All details describing how this process is done are provided in the next sections. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Example of interpreted test case},label={tcdecoded}]
<@\colorbox{red!60}{Aes}@>::<@\colorbox{orange!30}{new}@>(<@\colorbox{blue!30}{Key::new}@>(
    <@\colorbox{green!60}{\&[0x47, 0x1F, 0x88, 0x91, 0x0F, 0x33, 0xC6, 0x28]}@>
)).<@\colorbox{purple!30}{encrypt}@>(<@\colorbox{black!30}{\&[0x03, 0x0F, 0x74, 0x4D, 0xBA, 0x32, 0x0D, 0xFF]}@>, <@\colorbox{yellow!60}{AesMode::CBC}@>)
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Example test case},label={tc}]
<@\colorbox{red!60}{A3}@> <@\colorbox{orange!30}{68}@> <@\colorbox{blue!30}{62}@> 
    <@\colorbox{green!75}{0x08}@> <@\colorbox{green!60}{47 1F 88 91 0F 33 C6 28}@> 
<@\colorbox{brown!30}{0xC1}@> <@\colorbox{purple!30}{0E}@> <@\colorbox{black!45}{0x08}@> <@\colorbox{black!30}{03 0F 74 4D BA 32 0D FF}@> <@\colorbox{yellow!60}{AA}@> 
<@\colorbox{brown!60}{0xA0}@>
\end{lstlisting}
\end{minipage}

\subsection{Designing the compiler} \label{sec:compiler}
Like every compiler, this one also can be divided into two parts, the frontend and backend. The frontend is usually responsible for lexical and grammatical analysis of the input text. Since this compiler is created as a \textit{Rust}'s \textit{proc macro}, the \textit{Rust} compiler already does the lexical analysis. The macro just needs to convert the stream of tokens into objects representing the encoded program. Typically, the program is parsed into a syntax tree based on the grammar definition. Next, the compiler uses that tree to perform semantic analysis to check if the language rules aren't broken. The designed language has simple grammar rules as it doesn't support variables, functions, or methods. Furthermore, in case of this language, the backed will generate \textit{Rust} code which will be later compiled by the \textit{Rust} compiler into machine code. This allows omitting all steps related to semantic analysis or optimization, as these tasks will be completed by the \textit{Rust} compiler. 

\subsubsection{Compiler internals}
The \textit{proc macro} tool is a very powerful mechanism embedded inside \textit{Rust} language. It allows operating directly on the token stream, which is ideal for the creation of a compiler. Here the input is the source code of the designed language and the output is the transpiled code. Architecturally, the output code will contain an array of compiled fuzzer targets and a static block of code implementing the interface with \textit{QEMU}. To store the compiled functions in an array, it's best to unify the parameter types. In this case, the easiest solution is to make each of them take the test case as argument. These functions then construct the parameters and call the actual target method and return the result. The easiest way to implement the arguments decoding would be to provide the language's primitives as embedded functions and then create compositions of them based on the description. Unfortunately, since references are allowed, this approach won't work in every case. The reason being, that returning a reference to a local variable leads to memory corruption and is therefore forbidden in \textit{Rust}. That's why the code generator needs to construct the arguments in an imperative way. The easiest way of accomplishing this is to use the Static-Single Assignment form as described in chapter \ref{ssadec}. Here each value gets assigned to a variable only once, hence all of them will have a well-defined lifetime. Each of these values will last either to the final function call or when a new assignment will move it out. Thankfully, a variable whose value was moved out just cannot be access and will otherwise compile successfully. In conclusion, the compiler needs to encode each operation as a new variable with assigned value. These variable should have unique, not repeating label.

\paragraph{Objects cache}
The next issue which requires solving is whether to keep the created object for later use. Currently, after the fuzzing algorithm has finished its operation and the object is not needed, it is disposed. This is the easiest design, but has some inefficiencies. Primarily, disposing the object every time increases the test case usage. Similarly, \textit{fuzzers} like \cite{opteefuzz} keep an array of previous \textit{syscalls} return values to feed them into future calls. This allows the fuzzer to run faster, as many \textit{syscalls} require a special value which acts as an identifier to an object allocated in the kernel. This is called a file descriptor in Linux systems or a handle in \textit{OPTEE}. Besides that, keeping old objects helps the exploration, the reason being that passing a proper value as argument allows for completing the simplest data integrity checks. Furthermore, modifying a single object over and over again can help in triggering more sophisticated bugs. Here the issue is harder to solve for two reasons:
\begin{itemize}
    \item the objects are of different types, which requires employing some special data structures,
    \item for the object to be used it's needed to be moved out of the cache and put back at the same index afterwords to satisfy the borrow checker rules.
\end{itemize}
In \textit{Rust} the object cache can be implemented as a hash table containing \textit{enums} with associated types. Such \textit{enums} will in this case act similarly to a \textit{std::variant} data structure from \textit{C++}. This allows for moving out and putting back objects of different types at the same location.


\paragraph{Code generation example}
Let us consider an API description like that in listing \ref{lst:cred_dsc}. Here the \textit{fuzzer}'s target is a class named \textit{Creds} that defines only two constructors. These functions are named \textit{login} and \textit{register} and take only string literals as arguments. Each of this string is initialized with a random text taken from test case of length less than 32. It is done by the \textit{\#Str(\#Mod(\#U8,32))} expression. For clarity, this macros' composition has the following meaning:
\begin{itemize}
    \item \textit{\#Str(length)} - act like \textit{\#Slice(length)} but return string instead of a slice for easier type manipulation, underneath it the compiler will generate the code for \textit{\#Slice(length)} and wrap it in a function converting raw bytes to \textit{Rust}'s strings,
    \item \textit{\#Mod(a, b)} - performs modulo operation on its arguments, mathematically it returns $a \mod b$.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Creds class description.},label={lst:cred_dsc}]
Target {
    Creds {
        ctors {
            Creds::login(#Str(#Mod(#U8, 32)), #Str(#Mod(#U8, 32))),
            Creds::register(#Str(#Mod(#U8, 32)), #Str(#Mod(#U8, 32)))
        }
        functions {}
    }
}
\end{lstlisting} 
\end{minipage}

The compiled code for this example is shown in listing \ref{lst:compiler_out}. It can be seen, that the generated expression is in SSA form, as every new value is assigned to a new variable. To ensure that the labels are unique, the generator adds a number to the end of their names representing the order in which the labels were allocated. To generate code, the compiler runs a DFS algorithm against the syntax tree, which results in the reversed ordering of variable names. Consequently, the first operation to be compiled is the deepest in the tree. As it can be seen, the provided function is a lambda expression that takes two arguments. The first is named the target and holds the compiled array of functions. It is provided to allow for recursively start fuzzing other classes when needed. The other, called the buffer, is a wrapper for the test case that implements functions allowing for consuming the test byte by byte. It defines the following functions:
\begin{itemize}
    \item \textit{get\_u8(), get\_u16(), get\_u32()} - consumes the appropriate number of bytes and interprets the result as a number, it's implemented to support the \textit{\#U8, \#U16, \#U32} primitives,
    \item \textit{slice(length)} - consumes the requested number of bytes and returns them as a slice, it was added to enable the \textit{\#Slice(length)} macro,
    \item \textit{choice([option1, option2, ...]} - randomly draws a value from the provided array, this is what \textit{\#OneOf(option1, option2, ...)} macro uses underneath.
\end{itemize}
To clarify the code, let us analyze it line by line:
\begin{itemize}
    \item In line 2 - \textit{\_\_var\_2} is assigned with the result of \textit{get\_u8()} this is the result of compiling the \textit{\#U8} macro being the first argument to \textit{\#Mod(\#U8, 32)},
    \item In line 3 - \textit{\_\_var\_3} is assigned with a literal value of 32 which is the second argument to \textit{\#Mod(\#U8, 32)},
    \item In line 4 - \textit{\_\_var\_1} is assigned with the result of modulo operation of the two previously computed values,
    \item In line 5 - \textit{\_\_var\_0} is assigned with the result of the \textit{\#Str(length)} macro, as it can be seen it calls the \textit{buffer.slice(length)} function and then wraps the result in some \textit{Rust} utilities used to convert a byte array to a string literal with some error handling that can be neglected in this description.
\end{itemize}
Next, lines 8 to 11 perform the same operations as the described above, as the second argument to the \textit{login} function is described with the same expression.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Example of compiler output.},label={lst:compiler_out}]
|target: &Target, buffer: &mut Buffer| {
    let __var_2 = buffer.get_u8()?;
    let __var_3 = 32;
    let __var_1 = __var_2 % __var_3;
    let __var_0 = std::str::from_utf8(buffer.slice(__var_1 as usize)?)
        .map_err(|_| FuzzerError::Utf8Decoding)?
        .to_string();
    let __var_6 = buffer.get_u8()?;
    let __var_7 = 32;
    let __var_5 = __var_6 % __var_7;
    let __var_4 = std::str::from_utf8(buffer.slice(__var_5 as usize)?)
        .map_err(|_| FuzzerError::Utf8Decoding)?
        .to_string();
    Creds::login(__var_0, __var_4)
}
\end{lstlisting} 
\end{minipage}

\subsubsection{Generating test cases from unit tests} \label{sec:testint}
Preparing a good corpus before running the fuzzer is a good practice which can speed up the fuzzing process. Normally, gathering test cases isn't an issue when the target of \textit{fuzzing} is, for example, an image viewer. In the case of fuzzing APIs, the test cases are decoded to function calls, which makes them harder to collect. Naturally, a good place to gather corpus are unit tests for the \textit{fuzzed} target. The only issue left to solve is encoding back the function calls to \textit{fuzzer's} binary test cases format. This task requires implementing a process which will operate backwards when compared to the test case decoder module.

\paragraph{Inverting expressions}
Rewriting all unit tests to \textit{fuzzer's} binary test cases by hand is highly repetitive and inefficient and therefore should be automated. To limit the modifications needed to be applied to existing code, it's best to hook the target functions in the test suite. This enables us to trace the function's arguments values. When we take the traced value and take the expression that was used to create it we can try to solve for the test case bytes. To check if this is possible we need to check if all expressions in the API description language are invertible. In mathematics for an inverse function to exists the function needs to be a bijection. Unfortunately, not all the defined primitives meet this requirement. In detail the invertibility of each such primitive is explained as follows:
\begin{itemize}
    \item \textit{\#U8, \#U16, \#U32} - those expressions are bijections as every number has a unique representation in computer memory, provided we don't change computer architecture which might change the endianess,
    \item \textit{\#Slice(length)} - this is simple to reverse as this expression holds a slice of the original test case, so it's sufficient to just concatenate it,
    \item \textit{\#Api(name)} - this is just a mark which class will be fuzzed recursively and is therefore a compile time known constant making it reversible,
    \item \textit{\#OneOf(option1, option2, ...)} - here each value from the list is associated with a number from set containing natural number from 0 to count less one, as a result the compiler can generate a series of conditional statements checking which value was encountered and emit the proper index,
    \item \textit{\#Str(length)} - since this is derived from the \textit{\#Slice(length)} macro, it can also be concatenated after converting the text to bytes,
    \item \textit{\#Mod(a, b)} - the inverse of $y = x \mod n$ is $x = y + k \cdot n$ $\forall k \in \mathbb{N}$, the easiest solution is that for $ k=0 $, so I decided to yield \textit{a} as the inverse of the modulo operation.
\end{itemize}
Naturally, to fully inverse an expression each of its arguments needs to be inverted first, as during the \textit{fuzzing} process it will be decoded first. For example, while decoding the \textit{\#Slice(length)} primitive the expression passed as the length will be inverted first using the calculated length of the slice before it gets concatenated to the resulting test case. The same applies for the \textit{\#Mod(a, b)} whose inverse is actually the inverse of the expression passed as the \textit{a} parameter. Although, all described primitives are inversible, only the first one is a bijection on its domain. The domains of the other expressions were implicitly restricted to make it bijective. Of course, this is just a formal requirement for a function to be invertible, and the \textit{fuzzer} will work just fine even if it is no met. The only downside of omitting this requirement is the existence of many test cases which will be decoded to the same sequence of function calls. On the other hand, the inverting of a function call will yield only one encoding. Fortunately, genetic \textit{fuzzers} will not promote the same encoding over the others yielding the identical results, as it can't increase the coverage by finding a new path. 


\paragraph{Unit tests tracing design}
Tracing a function requires the ability to inspect each of the arguments' values as well as the return value. Ideally, we would like to prepend to the function's body code that will perform parameter analysis just before the original function's body might tamper with them. Next, the code should acquire and examine the return value. The most general way to catch the return value is to use the closure mechanism by wrapping the original function body in a lambda expression and invoking it. Then, the code may proceed with the examination of the return value and finish with actually returning it. The illustration of this concept is shown in listing \ref{lst:tracingdesign}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Unit tests tracing design.},label={lst:tracingdesign}]
fn some_function(argument1: type1, argument2: type2) -> return_type {
    inspect_argument1!(argument1);
    inspect_argument2!(argument2);

    let return_value = original_funcion_body();

    inspect_return_value!(return_value);
    return return_value;
}
\end{lstlisting}
\end{minipage}

\paragraph{Example of unit test tracing}
In detail, the easiest way to trace a function is to create a \textit{proc macro} that will prepend the function body with parameter inspecting code and append the return value handler. Since neither the arguments nor the return value is changed, there is no need to alter the function's signature. The result of applying such macro to the \textit{Creds::login} function can be seen in listing \ref{lst:tcrev}. The first thing that catches the eye is the usage of the singleton \textit{TcAssembler}. This object implements all the required utilities to glue a test case byte per byte. It basically provides the opposite methods to the \textit{Buffer} class that is used to consume test case during \textit{fuzzing}. The traced function starts by calling the \textit{select\_api} function with the class identifier passed as argument. This is done to tell the \textit{fuzzer} which class should be selected in the \textit{fuzzing} algorithm. The second argument, here provided by \textit{None} is the optional object identifier. Since, this is the constructor and the object is yet to be created, this field is missing. The true significance of it will be described later in this chapter. Overall, this function call yields the class's numerical identifier if the fuzzer is about to draw the first class to be fuzzed. Next, since the \textit{Creds::login} is a constructor, the constructor identifier is added to the test case by calling the \textit{select\_ctor} with the function identifier passed as parameter. Then follow the macros' invocation, which inverse each argument. These macros will be described later in the next paragraph. What remains is acquiring the return value by executing the original function's code in a block and inspecting it. This ends the transformation done by the tracing macros. What's left to describe is generating the parameter and return values inspectors.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Exmaple testcase reversing code.},label={lst:tcrev}]
pub fn login(user: String, password: String) -> Result<Self, Error> {
    TcAssembler::take()
        .select_api(Apis::Creds as u8, None)
        .select_ctor(encodings::__ctors_Creds::Creds_login as u8);
    __encode_Creds__Creds_login_arg_0__!(user);
    __encode_Creds__Creds_login_arg_1__!(password);
    let mut __ret__ = || {
        /*
            Original function code
        */
    }();
    __encode_Creds__Creds_login_epilogue__!(__ret__);
    __ret__
}
\end{lstlisting}
\end{minipage}


\paragraph{Arguments inspecting macros}
The macros used to inspect the arguments are created by the same compiler that is generating the actual \textit{fuzzer}. It is done because the \textit{proc macro} implementing the compiler is the only entity that has the description of the target. Additionally, there are no established communication channels between different macro invocation. Of course, a macro can always store information in the operating system as it has access to the file system, but this is not officially supported and cannot be relied on. Moreover, the order in which macros are evaluated in the project is implementation defined and might be unpredictable. For this reason, these macros are created along with the test case decoding algorithm. In detail, each of them will contain an appropriate sequence of calls to the \textit{TcAssembler} object that will inverse the arguments values based on the supplied expressions. The macros required by the \textit{Creds::login} function are shown in listing \ref{lst:geninv}. It can be seen that the \textit{\_\_encode\_Creds\_\_Creds\_login\_arg\_0\_\_} macro has one parameter being a label. That argument holds the traced parameter value and will be used to inverse the expressions supplied in the target description. For clarity, let us recall that both of the arguments were initialized by the following expression \textit{\#Str(\#Mod(\#U8, 32))}. This directly translates to the shown function calls to the \textit{TcAssembler} object. Slicing from outside, the expression begins with a \textit{\#Str(length)}. This is inverted as the inverse of length, which is calculated as the actual string size, and the content of the text literal. Next, comes the \textit{\#Mod(a, b)} part, whose inverse evaluates to the inverse of \textit{a}. Finally, the inverse of \textit{\#U8} yields a single byte with the value of the text literal length. This can be seen in the referenced example. In line 4 the \textit{add\_byte} function is called to append the length of the text which is then followed by a call to \textit{add\_bytes} with the content of the string converted to a byte array. The description of the macro that inverts the second argument can be omitted, as in this case it has literally the same body.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Generated macros which inverse the arguments},label={lst:geninv}]
macro_rules! __encode_Creds__Creds_login_arg_0__ {
    ($label : ident) => {
        TcAssembler::take()
            .add_byte($label.len() as u8)
            .add_bytes($label.as_bytes());
    };
}
\end{lstlisting}
\end{minipage}

\paragraph{Inspection of the return value}
Inspection of the return value might seem unnecessary for the purpose of creating the test case, as only function arguments are encoded in the test case. However, this proved to be necessary for the task of creating test cases from traced functions. Let us imagine that the unit test function created two objects of type \textit{Creds} which are then used to call some other \textit{APIs}. This situation shows a new, previously not described issue. Up to this point, there is no functionality in the design that allows for identifying the created objects. As a result, the tracing function cannot assign correctly which object the member function should be called on. For example, in languages such as \textit{Python} each object can be identified by its pointer which is returned by the built-in \textit{id()} function. Unfortunately, there is no similar mechanism in \textit{Rust}. For this reason, the objects need to have a field which can identify different instances. This additional field can be added through another \textit{proc macro} that is acting on the class definition itself. It's enough to add the field with two member function, allowing to get and set the identifier. Now, distinguishing between object is possible, so the only required thing to do is to set the \textit{id} value at the end of the constructor. This is where the return value inspection macro becomes handy. An example of return value inspecting macro used in the constructor of the \textit{Creds} class is shown in listing \ref{lst:retvalinsp}. There can be seen that this macro uses a \textit{match} statement to check if the return value contains an error. In case, no error was encountered, the \textit{\_\_set\_id\_\_()} member function is called on the newly created object to set its identifier. This, beside the \textit{\_\_get\_id\_\_()}, is the specially added member function along with the hidden \textit{id} field itself. This identifier can later be used by the added tracing code to encode the correct identifier in the test case, so that the fuzzer will take the correct object from the cache. The identification of the objects happens inside the \textit{select\_api} function of the \textit{TcAssembler} object. We previously said that the second argument is initialized to \textit{None} inside a constructor. Of course, a constructor creates the object, so there is no associated object. However, this is not the case in member functions, where the second argument of the \textit{select\_api} function is populated with the object's identifier. This then allows the fuzzer to select the proper object from the object cache.


\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Return value inspecting macro},label={lst:retvalinsp}]
macro_rules! __encode_Creds__Creds_login_epilogue__ {
    ($ret : ident) => {
        match &mut $ret {
            Ok(obj) => obj.__set_id__(),
            Err(_) => {}
        }
    };
}
\end{lstlisting}
\end{minipage}

