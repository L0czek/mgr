\cleardoublepage
\section{Test environment design} \label{chap:envir}

% TODO wywaliÄ‡?
%\subsection{Requirements and design choices}
%The fuzzing target will be a set of classes with member functions which compose the interface of a secure service. Of course, in Rust there are no classes as it has only structs and implementations, but for simplicity I will refer to struct with member functions as classes. The fuzzer will create objects of these classes and then proceed with fuzzing their member functions. The use of generics and explicit lifetime parameters is not supported to simplify the design. The target will be running as a trusted application inside \textit{OPTEE OS}. This program will be compiled with all necessary utilities to communicate with the fuzzer through \textit{QEMU}.

\subsection{Overview}

This chapter focuses on exploring the inner workings of the test case decoder mentioned in chapter \ref{chap:why}. It can be divided into a couple of submodules as seen in figure \ref{fig:cntdiag}. The main task of this module is to interpret test cases from \textit{AFLplusplus} fuzzer and call the secure services based on the received data. This is accomplished by the following stages:
\begin{enumerate}
    \item The preparation phase begins with the description which tells the fuzzer how to use the interface the target provides. This step is called \textit{API description} and utilizes a specially created language. The design and some examples of this domain-specific language are provided in section \ref{sec:lang}.
    \item Next, the target description is fed to the compiler which generates the so-called \textit{executor}. This is done by implementing a special \textit{proc macro} which takes as an argument the source code of the special language end emits \textit{Rust} code implementing the test case decoder. It is described in section \ref{sec:compiler}.
    \item Finally, the generated \textit{executor} module communicates with the \textit{QEMU} to fetch the test cases and then interprets them using the compiled code. During execution of the test case, this module calls directly the target which is represented by the \textit{Secure services} module. The actual algorithm which controls the fuzzing process is walked through in section \ref{sec:testcase}.
\end{enumerate}
The second task is all about seeding the \textit{AFLplusplus} corpus using unit tests of the target. As already discussed preparing a robust corpus helps the fuzzer explore the target. The corpus elements can be treated as examples of how to call the target's interface. In a nutshell, a good corpus might increase the fuzzer perfomance by shortening the fuzzing time required to uncover the same number of bugs. Since the compiler is used to generate the test case interpreter it can also be used to go the opposite way and create test cases from function calls. This process works as follows:
\begin{enumerate}
    \item The compiler uses the target description to generate the test case reverser. In detail, the generated \textit{Rust} source code contains an augmented replica of the target that acts as a proxy and traces the function parameters to assemble the test cases. This process is described in section \ref{sec:testint}.
    \item The module containing the unit tests is modified to use the generated replica to seamlessly introduce instrumentation. After each unit test the generated sequence of bytes is returned to \textit{QEMU} to be saved in the corpus folder of \textit{AFLplusplus}.
\end{enumerate}
Similarly, like in chapter \ref{chap:why} the background colors are used to distinguish open-source modules from the custom ones, created by me. Just as a quick reminder the colors mean the following:
\begin{itemize}
    \item \colorbox{green!30}{light green} - marks an open-source project which was only slightly modified or adapted,
    \item \colorbox{orange!30}{orange} - marks components which were fully created by me,
    \item \colorbox{yellow!30}{yellow} - marks components whose modification were required,
    \item \colorbox{green!60}{green} - marks an unmodified open source component.
\end{itemize}


\tikzstyle{opensource} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!30]
\tikzstyle{custom} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=orange!30]
\tikzstyle{opensourcemod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!60]
\tikzstyle{custommod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=orange!60, text width=2cm]
\tikzstyle{modifiedmod} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=yellow!30]
\tikzstyle{host} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=brown!30]

\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzstyle{darrow} = [thick,<->,>=stealth]

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \node (api) [custommod] { API description };
        \node (compiler) [custommod, right of=api, xshift=3cm] { Compiler };
        \node (executor) [custommod, right of=compiler, xshift=3cm] { Executor };
        \node (rev) [custommod, below of=compiler, yshift=-1cm] { Test case reverser };
        \node (unittests) [custommod, below of=api, yshift=-1cm] { API unit tests };
        
        \begin{pgfonlayer}{background2}
            \node (tcdecoder) [custom, fit={(api) (compiler) (executor) (rev) (unittests)}, label={Test case decoder}, text width=12cm, text height=4cm] {};
        \end{pgfonlayer}

        \node (services) [custommod, right of=executor, xshift=3cm] { Secure services };
        \node (kernel) [opensourcemod, above of=compiler, yshift=1.5cm, text width=15.5cm, xshift=1.75cm] { OPTEE OS kernel };]

        \begin{pgfonlayer}{background1}
            \node (opteeos) [opensource, fit={(kernel) (tcdecoder) (services)}, label={ OPTEE OS }] {};]
        \end{pgfonlayer}


        \node (fuzzint) [custommod, below of=rev, yshift=-1.5cm] { Fuzzer integration };

        \begin{pgfonlayer}{background0}
            \node (qemu) [opensource, fit={(opteeos) (fuzzint)}, label={ QEMU }, text height=9.2cm] {};
        \end{pgfonlayer}
        
        \draw [arrow] (api) -- (compiler);
        \draw [arrow] (unittests) -- (rev);
        \draw [arrow] (compiler) -- (rev);
        \draw [arrow] (compiler) -- (executor);
        \draw [arrow] (rev) -- (fuzzint);
        \draw [darrow] (executor) -- (services);
        \draw [arrow] (fuzzint) -| (executor); 
        \draw [darrow] (services) --++ (0cm, 2cm);
    \end{tikzpicture}
    \caption{Modules diagram.}
    \label{fig:cntdiag}
\end{figure}

%\subsection{API description language features} % TODO move lower
%Let us assume the target API uses simple types and objects passed by value or reference. For this reason, I didn't implement support for generics and lifetime syntax. The mentioned lifetime is a special feature of the \textit{Rust} language. It was designed to allow the programmer to bind the lifetime of different entities together. For clarity, these extensions' syntax is similar to \textit{C++} templates. It features special parameters that allow type specialization based on:
%\begin{enumerate}
%    \item other types denoted as labels, for example \textit{T},
%    \item constant values, for example \textit{const N},
%    \item lifetime symbol which allows for explicitly connecting lifetimes of different objects, for example \textit{'a}.
%\end{enumerate}
%Typically, such syntax becomes handy in a situation where one field of a struct is a reference. In such cases, \textit{Rust} compiler requires the programmer to specify explicitly the lifetime of the object and the reference. Naturally, in most cases the reference will live as long as the object, so their lifetime can be denoted by the same symbol as shown in listing \ref{lst:generics}. There we can see a definition of struct \textit{Buffer}, which has an explicit lifetime \textit{'a} and depends on some type \textit{T}. This struct holds one item which is a reference to an array of \textit{T} type elements which also has an explicit lifetime \textit{'a}. This tells the compiler that the reference will live as long as the object holding it. Removing this language features described above forbids the generated code to use compile time polymorphism, leaving the runtime one available. However, the \textit{Rust} compiler has the ability to perform type deduction based on how the object is used. This allows for omitting some type specification in simple cases such as declaring an array if the code adds an element of known type.
%
%To call a function, we need to describe how to construct its arguments. Therefore, the designed language needs to offer primitives enabling easy construction of simple types such as numbers or text literals. Each of these arguments can be instantiated before the function call and destroyed after, so that all \textit{Rust's} lifetime rules are preserved. What is more complicated is invoking classes' member functions. Here, the object itself needs to be constructed beside the parameters. This can be easily done, as an object constructor relies sole on the function arguments. All of this discussion leaves us with a simple functional language with a couple of primitives defined.
%
%\begin{minipage}{\linewidth}
%\begin{lstlisting}[language=rust,caption={Generic and lifetime parameter example.},label={lst:generics}]
%struct Buffer<'a, T> {
%    slice: &'a [T]
%}
%\end{lstlisting}
%\end{minipage}


\subsection{Structure-aware fuzzing}
Many targets like the discussed operating systems or any services exposing a function-like interface require a structured data format. Here these formats refer to objects being supplied as function parameters and objects to call member functions on. Currently, the \textit{Rust} community designed a special library called \textit{Arbitrary} in \cite{rustfuzzbook}, it can be used to construct objects from random bytes. This crate requires the use of a special macro that generates the deserialization code based on the structure content. This can be a great tool aiding the creation of objects but has a couple of disadvantages. First, it works seamlessly, which can be a great feature but also doesn't allow for more control over how the objects are created. As a result, small changes in the input sequence might lead to large changes in resulting objects. This can have a destabilizing effect on the genetic fuzzing algorithm. Furthermore, when fuzzing an interface with a hidden state, applying operations on previously created objects can be beneficial. By hidden state, I mean that part of it is stored outside the object itself. The \textit{file descriptor} from \textit{Linux} operating system is a good example of such an object, as it just points indirectly to a structure stored inside the kernel. 

The application of the \textit{Arbitrary} crate is shown in listing \ref{lst:arb_crate}. There the traits from \textit{Arbitrary} crate will be implemented for the \textit{Friend} \textit{enum} which has two options with each of them containing an associated object. The macro will take care of encoding different options and their types, as long as all types that the \textit{Friend} \textit{enum} relies on also implement \textit{Arbitrary} crate. Naturally, since \textit{usize} and \textit{String} types are standard types taken from \textit{Rust's} standard library, the \textit{Arbitrary} crate is already implemented for them. The next sections explore another way of constructing objects from byte sequences that can give more control over object creation.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=Rust,caption={Example of \textit{Arbitrary} crate usage.},label={lst:arb_crate}]
#[derive(Arbitrary)]:
pub enum Friend {
    Buddy { name: String },
    Pal { age: usize },
} 
\end{lstlisting} 
\end{minipage}

The inner workings of this library are quite simple. It defines a custom deserialization algorithm for each of the standard types. For clarity, in the \textit{Friend} \textit{enum} example the types can be handled as follows:
\begin{itemize}
    \item the \textit{usize} implements the \textit{from\_le\_bytes} function which can be used directly, for example \textit{usize::from\_le\_bytes([1, 0, 0, 0, 0, 0, 0, 0])} returns an \textit{usize} with the value of $1$,
    \item the \textit{String} type is just a collection of characters, so as every iterable entity this can be serialized as its length which is a number, and then followed by the characters,
    \item finally the \textit{enum} itself can be treated as a union of different entities which are distinguished by an assigned number that is unique to each option, after the identifier is saved, the rest of the \textit{enum} can be treated as a \textit{union} from \textit{C} language which means that we can just serialize the object associated with the chosen option right after the identifier.
\end{itemize}

\subsubsection{Design of the target description language} \label{sec:lang}
In the big picture, the API description is a list of classes, where every entry consists of two sets:
\begin{enumerate}
    \item the set of constructors, which tell the fuzzer how to construct the object, seen as the \textit{ctor} block,
    \item the set of member functions that can be called on the object, seen as the \textit{functions} block.
\end{enumerate}
These sets store references to functions with descriptions showing how to construct each argument. Each element of these sets is a function with expressions showing how every argument can be constructed. To accomplish this the language needs to provide several primitives to allow for instantiating parameters from test cases. This will vary based on the fuzzed target, as different APIs might require different types of arguments. To cover the most common types of parameters, the language should implement the following primitives:
\begin{itemize}
    \item \textit{\#U8, \#U16, \#U32} - expressions allowing the creation of numbers,
    \item \textit{\#Slice(length)} - to take a slice of the test case of provided length and return as if it was an array, 
    \item \textit{\#Api(name)} - to specify a reference to another class in the target list,
    \item \textit{\#OneOf(option1, option2, ...)} - to draw at random an option from the provided list,
    \item \textit{\#Mod(a, b)} - performs module operation $a \mod b$,
    \item \textit{ref } - to take an immutable reference of the argument.
\end{itemize}
To summarize the design in a formal way I provided the grammar rules in \textit{EBNF} form in listing \ref{lst:grammar}. It contains all symbols that are used in the designed language except for \textit{RUST\_EXPRESSION}. I omitted the description for this symbol as it refers to the expression from \textit{Rust} language and is not part of my design. As already stated, the target description starts with the keyword \textit{Target} which encapsulates list of classes. Each class description starts with its name and provides a set of constructors using the keyword \textit{ctor} and a set of member functions with the \textit{functions} keyword. The function call description begins with the reference to the actual method, which is then followed by a list of expressions stored inside parenthesis. The expressions can be constructed by using any composition of the previously defined primitives.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Target description language grammar.},label={lst:grammar}]
LETTER = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" 
DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
IDENTIFIER = LETTER, { LETTER | DIGIT | "_" }

TARGET = "Target", "{", API, { ",", API } "}"
API = IDENTIFIER, "{", CTOR_LIST, FUNC_LIST, "}"
CTOR_LIST = "ctor", "{", CTOR_CALL_DESCRIPTION, {",", CALL_DESCRIPTION }, "}"
FUNC_LIST = "functions", "{", FUNC_CALL_DESCRIPTION?, { ",", CALL_DESCRIPTION }, "}"
CTOR_CALL_DESCRIPTION = PATH, "(", [ ARG ], { ",", ARG }, ")", "->", EXPR
FUNC_CALL_DESCRIPTION = IDENTIFIER, "(", [ ARG ], { ",", ARG }, ")", "->", EXPR
PATH_ELEMENT = IDENTIFIER | "super" | "crate"
PATH = PATH_ELEMENT, { "::", PATH_ELEMENT }
ARG = "#", MACRO | "ref" ARG | RUST_EXPRESSION
MACRO = "U8" | "U16" | "U32" | "Slice", "(", ARG, ")" | "Api", "(", IDENTIFIER, ")" |
        "OneOf", "(", RUST_EXPRESSION, { ",", RUST_EXPRESSION }, ")" |
        "Mod", "(", ARG, ",", ARG, ")"
\end{lstlisting}    
\end{minipage}

An example description of the discussed target can be seen in listing \ref{lst:desc}. It begins with the \textit{Target} keyword, which encapsulates the list of targets. Then follow the definitions of the classes. It begins with the class name, which is then followed by the list of constructors, denoted as \textit{ctor}, and member functions. As it can be seen, the \textit{Key} class has one constructor named \textit{Key::new}, whose argument is initialized by \textit{\#Slice(\#U8)}. This expression returns a slice of the test case of length that is also taken from the test case. In detail, this expression will first read a byte and convert it to a natural number, as it is the parameter to the \textit{\#Slice()} macro. Then it will read the requested number of bytes and return it. This slice will be then passed as the argument to the constructor. The next entry in the \textit{Key} class defines one member function. The \textit{wrap} method takes a reference to another \textit{Key} object, which can be encoded in this language as \textit{ref \#Api(Key)}. Here, just as described earlier, the fuzzer will recursively begin fuzzing the \textit{Key} class to return the other object. After that, the \textit{ref} operator will take a reference and return it. This finishes the \textit{Key} class description, which is then followed by the specification of the \textit{Aes} one. Just like the former one, this also starts with the specification of the constructor which takes a key object. However, this time the function takes ownership of the argument. As a result, its description is missing the \textit{ref} keyword when compared to the argument of the \textit{wrap} function. Then follow the member functions of \textit{Aes}. This time there are two entries, nevertheless their arguments are pairwise of the same type and differ just semantically. Therefore, only the entry for \textit{encrypt} function will be described. Its first argument is the plaintext passed as a byte slice, this is initialized just like the argument in \textit{Key} class constructor. Next, follows the cipher block mode selection. It is initialized by the \textit{\#OneOf(AesMode::ECB, AesMode::CBC)}, which will randomly draw one of the provided options. This completes the target description.

%\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={API description in the created language.}, label={lst:desc}]
Target {
    Key {
        ctor {
            Key::new(#Slice(#U8))
        },
        functions {
            wrap(ref #Api(Key))
        }
    },
    Aes {
        ctor {
            Aes::new(#Api(Key))
        },
        functions {
            encrypt(#Slice(#U8), #OneOf(AesMode::ECB, AesMode::CBC)),
            decrypt(#Slice(#U8), #OneOf(AesMode::ECB, AesMode::CBC))
        }
    }
}    
\end{lstlisting}
%\end{minipage}

\paragraph{Implementation of the language primitives}
Each of the listed primitives can be implemented as an expression that transforms appropriate bytes from the test case and yields the required entity. The \textit{\#U8, \#U16, \#U32} can be implemented by just taking some number of bytes from the test case, arranging them in, for example, little-endian order, and interpreting them as a natural number. Next, the \textit{\#Slice(length)} macro takes the length as an argument and reads bytes from the test case to return it as a reference. The \textit{\#Api(name)} primitive is a reference to another class in the target list. By itself it doesn't consume test case bytes as it just recursively starts the fuzzing process again. This time, the step in the algorithm where the fuzzer chooses the class that begins the fuzzing process is omitted. Next, the \textit{\#OneOf(option1, option2)} is handled just like the other previously described lotteries. In detail, a byte is consumed and interpreted as a natural number. Naturally, the range of value is reduced to the number of given options by a modulo operation. In the generated code this operator is encoded as a sequence of conditional statements where each one handles one option. Last but not least, the \textit{ref} keyword emits a \textit{Rust's} \textit{\&} operator and doesn't impact the test case processing.

To illustrate how the bytes in the test case are used, let us assume that the genetic algorithm inside \textit{AFLplusplus} generated a sequence of bytes seen in listing \ref{tc}. Naturally, these bytes aren't taken from a working example and are stated here just to demonstrate the point. Next, this test case can be coupled with its exemplary interpretation shown in listing \ref{tcdecoded}. For clarity, the corresponding parts between those listings are marked using the same background color. In detail, the test case decodes as follows:
\begin{itemize}
    \item \colorbox{red!60}{A3} is used to select \textit{Aes} class,
    \item \colorbox{orange!30}{68} chooses the \textit{Aes} constructor, the \textit{Aes::new} method,
    \item \colorbox{blue!30}{62} selects the \textit{Key} class constructor,
    \item \colorbox{green!75}{0x08} tell how many bytes to read to the requested slice,
    \item \colorbox{green!60}{47 1F 88 91 0F 33 C6 28} is used as an argument for the Key's constructor,
    \item \colorbox{brown!30}{0xC1} this is a special control-flow byte, it will be discussed later during the fuzzing process design, it allows the test case interpretation to continue,
    \item \colorbox{purple!30}{0E} draws the member function to call on the created \textit{Aes} object,
    \item \colorbox{black!45}{0x08} tell how many bytes to read to the requested slice,
    \item \colorbox{black!30}{03 0F 74 4D BA 32 0D FF} is used as plaintext,
    \item \colorbox{yellow!60}{AA} selects the cipher block chaining mode,
    \item \colorbox{brown!60}{0xA0} this is also a control-flow byte but this time it stops the fuzzing process.
\end{itemize}
Of course, in the final setup, these test cases are passed to compiled code for execution. All details describing how this process is done are provided in the next sections. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Example of interpreted test case.},label={tcdecoded}]
<@\colorbox{red!60}{Aes}@>::<@\colorbox{orange!30}{new}@>(<@\colorbox{blue!30}{Key::new}@>(
    <@\colorbox{green!60}{\&[0x47, 0x1F, 0x88, 0x91, 0x0F, 0x33, 0xC6, 0x28]}@>
)).<@\colorbox{purple!30}{encrypt}@>(<@\colorbox{black!30}{\&[0x03, 0x0F, 0x74, 0x4D, 0xBA, 0x32, 0x0D, 0xFF]}@>, <@\colorbox{yellow!60}{AesMode::CBC}@>)
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Example test case.},label={tc}]
<@\colorbox{red!60}{A3}@> <@\colorbox{orange!30}{68}@> <@\colorbox{blue!30}{62}@> 
    <@\colorbox{green!75}{0x08}@> <@\colorbox{green!60}{47 1F 88 91 0F 33 C6 28}@> 
<@\colorbox{brown!30}{0xC1}@> <@\colorbox{purple!30}{0E}@> <@\colorbox{black!45}{0x08}@> <@\colorbox{black!30}{03 0F 74 4D BA 32 0D FF}@> <@\colorbox{yellow!60}{AA}@> 
<@\colorbox{brown!60}{0xA0}@>
\end{lstlisting}
\end{minipage}

\subsection{Designing the compiler} \label{sec:compiler}
Like every compiler, this one also can be divided into two parts, the frontend and backend. The frontend is usually responsible for lexical and grammatical analysis of the input text. Since this compiler is created as a \textit{Rust's} \textit{proc macro}, the \textit{Rust} compiler already does the lexical analysis. The macro just needs to convert the stream of tokens into objects representing the encoded program. Typically, the program is parsed into a syntax tree based on the grammar definition. Next, the compiler uses that tree to perform semantic analysis to check if the language rules aren't broken. The designed language has simple grammar rules as it doesn't support variables, functions, or methods. Furthermore, in the case of this language, the backend will generate \textit{Rust} code which will be later compiled by the \textit{Rust} compiler into machine code. This allows omitting all steps related to semantic analysis or optimization, as these tasks will be completed by the \textit{Rust} compiler. 

\subsubsection{Compiler internals}
The \textit{proc macro} tool is a very powerful mechanism embedded inside \textit{Rust} language. It allows operating directly on the token stream, which is ideal for the creation of a compiler. Here the input is the source code of the designed language and the output is the transpiled code. Architecturally, the output code will contain an array of compiled fuzzer targets and a static block of code implementing the interface with \textit{QEMU}. To store the compiled functions in an array, it is best to unify the parameter types. In this case, the easiest solution is to make each of them take the test case as an argument. These functions then construct the parameters to call the actual target method and return the result. The easiest way to implement the arguments decoding would be to provide the language's primitives as embedded functions and then create compositions of them based on the description. Unfortunately, since references are allowed, this approach won't work in every case. The reason is, that returning a reference to a local variable leads to memory corruption and is therefore forbidden in \textit{Rust}. That is why the code generator needs to construct the arguments imperatively. The easiest way of accomplishing this is to use the Static-Single Assignment form as described in chapter \ref{ssadec}. Here each value gets assigned to a variable only once, hence all of them will have a well-defined lifetime. Each of these values will last either to the final function call or when a new assignment moves it out. Thankfully, a variable whose value was moved out just cannot be access and will otherwise compile successfully. In conclusion, the compiler needs to encode each operation as a new variable with an assigned value. These variables should have unique and not repeating labels.

\paragraph{Objects cache}
The next issue that requires solving is whether to keep the created object for later use. Currently, after the fuzzing algorithm has finished its operation and the object is not needed, it is disposed of. This is the easiest design but has some inefficiencies. Primarily, disposing of the object every time increases the test case usage. Similarly, fuzzers like \cite{opteefuzz} keep an array of previous \textit{syscalls} return values to feed them into future calls. This allows the fuzzer to run faster, as many \textit{syscalls} require a special value acting as an identifier to an object allocated in the kernel. This is called a file descriptor in Linux systems or a handle in \textit{OPTEE}. Besides that, keeping old objects helps the exploration, the reason being that passing a proper value as an argument allows for completing the simplest data integrity checks. Furthermore, modifying a single object over and over again can help in triggering more sophisticated bugs. Here the issue is harder to solve for two reasons:
\begin{itemize}
    \item the objects are of different types, which requires employing some special data structures,
    \item for the object to be used it needs to be moved out of the cache and put back at the same index afterward to satisfy the borrow checker rules.
\end{itemize}
In \textit{Rust} the object cache can be implemented as a hash table containing \textit{enums} with associated types. Such \textit{enums} will in this case act similarly to a \textit{std::variant} data structure from \textit{C++}. This allows for moving out and putting back objects of different types at the same location.


\paragraph{Code generation example}
Let us consider an API description like in listing \ref{lst:cred_dsc}. Here the fuzzer's target is a class named \textit{Creds} that defines only two constructors. These functions are named \textit{login} and \textit{register} and take only string literals as arguments. Each of these strings is initialized with a random text taken from a test case of length less than 32. It is done by the \textit{\#Str(\#Mod(\#U8,32))} expression. For clarity, this macro composition has the following meaning:
\begin{itemize}
    \item \textit{\#Str(length)} - act like \textit{\#Slice(length)} but return string instead of a slice for easier type manipulation, underneath it the compiler will generate the code for \textit{\#Slice(length)} and wrap it in a function converting raw bytes to \textit{Rust}'s strings,
    \item \textit{\#Mod(a, b)} - performs modulo operation on its arguments, mathematically it returns $a \mod b$.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Creds class description.},label={lst:cred_dsc}]
Target {
    Creds {
        ctors {
            Creds::login(#Str(#Mod(#U8, 32)), #Str(#Mod(#U8, 32))),
            Creds::register(#Str(#Mod(#U8, 32)), #Str(#Mod(#U8, 32)))
        }
        functions {}
    }
}
\end{lstlisting} 
\end{minipage}

The compiled code for this example is shown in listing \ref{lst:compiler_out}. It can be seen, that the generated expression is in SSA form, as every new value is assigned to a new variable. To ensure that the labels are unique, the generator adds a number to the end of their names representing the order in which the labels were allocated. To generate code, the compiler runs a \textit{Depth First Search} algorithm against the syntax tree, which results in the reversed ordering of variable names. Consequently, the first operation to be compiled is the deepest in the tree. As can be seen, the provided function is a lambda expression that takes two arguments. The first is named the target and holds the compiled array of functions. It is provided to allow for recursively start fuzzing of other classes when needed. The other called the buffer, is a wrapper for the test case that implements functions allowing for consuming the test byte by byte. It defines the following functions:
\begin{itemize}
    \item \textit{get\_u8(), get\_u16(), get\_u32()} - consumes the appropriate number of bytes and interprets the result as a number, it is implemented to support the \textit{\#U8, \#U16, \#U32} primitives,
    \item \textit{slice(length)} - consumes the requested number of bytes and returns them as a slice, it was added to enable the \textit{\#Slice(length)} macro,
    \item \textit{choice([option1, option2, ...]} - randomly draws a value from the provided array, this is what \textit{\#OneOf(option1, option2, ...)} macro uses underneath.
\end{itemize}
To clarify the code, let us analyze it line by line:
\begin{itemize}
    \item In line 2 - \textit{\_\_var\_2} is assigned with the result of \textit{get\_u8()} this is the compiled \textit{\#U8} macro which is also the first argument to \textit{\#Mod(\#U8, 32)},
    \item In line 3 - \textit{\_\_var\_3} is assigned with a literal value of 32 which is the second argument to \textit{\#Mod(\#U8, 32)},
    \item In line 4 - \textit{\_\_var\_1} is assigned with the result of modulo operation of the two previously computed values,
    \item In line 5 - \textit{\_\_var\_0} is assigned with the result of the \textit{\#Str(length)} macro, as it can be seen it calls the \textit{buffer.slice(length)} function and then wraps the result in some \textit{Rust} utilities used to convert a byte array to a string literal with some error handling that can be neglected in this description.
\end{itemize}
Next, lines 8 to 11 perform the same operations as discussed above, as the second argument to the \textit{login} function is described with the same expression.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Example of compiler output.},label={lst:compiler_out}]
|target: &Target, buffer: &mut Buffer| {
    let __var_2 = buffer.get_u8()?;
    let __var_3 = 32;
    let __var_1 = __var_2 % __var_3;
    let __var_0 = std::str::from_utf8(buffer.slice(__var_1 as usize)?)
        .map_err(|_| FuzzerError::Utf8Decoding)?
        .to_string();
    let __var_6 = buffer.get_u8()?;
    let __var_7 = 32;
    let __var_5 = __var_6 % __var_7;
    let __var_4 = std::str::from_utf8(buffer.slice(__var_5 as usize)?)
        .map_err(|_| FuzzerError::Utf8Decoding)?
        .to_string();
    Creds::login(__var_0, __var_4)
}
\end{lstlisting} 
\end{minipage}

\subsubsection{Designing the fuzzing process} \label{sec:testcase}
After the target description language has been thoroughly discussed we can move to designing the fuzzing algorithm. This part is responsible for choosing the order of classes and member functions that will be tested. Naturally, this algorithm uses the target description to instantiate the parameters for the tested function calls, as it was discussed above.
Overall, the fuzzing process consists of several steps repeated in a loop:
\begin{enumerate}
    \item fetching the test case from the hypervisor,
    \item running the test case using the test case decoder,
    \item reporting back to the hypervisor if anything has happened,
    \item preparing to run the next test.
\end{enumerate}
The communication with the hypervisor was described in the previous chapter. The next thing that needs to be discussed is the test case decoding algorithm. Its simplified version is presented in algorithm \ref{alg:syscall_decode}. The description uses several terms and entities having the following meanings:
\begin{itemize}
    \item $i$ - is the iterator indexing the test case received from the fuzzer,
    \item $API$ - this refers to the class which will be fuzzed,
    \item $APIs$ - this is the array of all classes that were described in the special language,
    \item $testcase$ - as the name suggests this is the received test case from \textit{AFL++} which is stored as an array of bytes,
    \item $testcase[i++]$ - this is an indexing expression that takes i'th byte from the test case and increments $i$,
    \item $API.constructor$ - it refers to all the described functions creating an object of a specific class,
    \item $API.functions$ - this refers to all member functions of the class.
\end{itemize}
This code is invoked in a loop until the entire test case is exhausted. In the first step, the class from which the fuzzing will begin is chosen. The selection process is based on drawing uniformly from a pool of options. The fairness of the lottery is ensured by taking a byte from the test case, interpreting it as a natural number, and then limiting the range of values by performing a modulo operation. Of course, when the number of choices is greater than 255 more bytes need to be used. In my case, this was always enough, as rarely the fuzzer would need to choose from more than a couple of values. 
Naturally, the source of randomness of this method is not a true random generator as the test cases need to be reproducible. As a result, the discussed algorithm is just a mapping between bytes from the test case and symbols used by this algorithm. The real source of randomness in this setup is therefore the genetic algorithm inside \textit{AFL++} which uses a true random number generator to mutate and create new test cases. After the first target class is chosen, the fuzzer proceeds with selecting a constructor which will be used to create the object. Naturally, there may be many ways to construct an object of some type, therefore the constructor is also drawn just like the target in the first place. Next, the chosen function is called, and the return object is saved. When this is done, the fuzzer starts a loop which will call the member functions. This loop repeats until two conditions hold:
\begin{itemize}
    \item the end of the test case was not reached,
    \item the exit condition is not met.
\end{itemize}
The second special check is implemented to allow breaking the loop based on values in the test case. In detail, the fuzzer continues the loop until the drawn boolean stays true. This might look unnecessary but is essential to support the ability to reverse the fuzzing process described later in this chapter. Inside this loop, the fuzzer selects and calls the class member functions. The selection mechanism again conducts a uniform draw as established above. In the end, the object is returned to the caller. This is necessary to support the situation where a function from one class takes an object of the other as an argument. In such cases, the fuzzing of the selected function is interrupted, and this algorithm is recursively run against the dependency. Finally, after all exit conditions are met, the hypervisor is informed of the fuzzing result.

\begin{algorithm}
    \begin{algorithmic}
        \State $i \gets 0$
        \State $API \gets APIs[testcase[i++] \mod length(APIs)]$
        \State $constructor \gets API.constructors[testcase[i++] \mod length(API.constructors)]$
        \State $obj, i \gets constructor(testcase, i)$
        \While{$testcase[i++] \mod 2 \&\& i < length(testcase)$}
            \State $function \gets API.functions[testcase[i++] \mod length(API.functions)]$
            \State $i \gets obj.function(testcase, i)$
        \EndWhile
        \State \Return $obj$
    \end{algorithmic}
    \caption{System calls decoding algorithm.}
    \label{alg:syscall_decode}
\end{algorithm}

\paragraph{Illustration of the algorithm}
An example of a target API is presented in listing \ref{lst:extarget}. It consists of two classes providing some basic security features. The first is a cryptographic key storage utility. It can be seen in its definition that it holds the keys as an anonymous field of a byte array type. In \textit{Rust} a \textit{Vec} is a similar container to \textit{std::vector} from \textit{C++}. This class defines two functions:
\begin{enumerate}
    \item a constructor named \textit{new} which takes a key as a slice of bytes,
    \item a function named \textit{wrap} which encrypts a key using another that is provided as an argument by a reference to another \textit{Key} object.
\end{enumerate}
The latter class implements the AES cipher. Similarly, as the \textit{Key} class, this one also has one anonymous field storing the cryptographic key. It defines three functions which go as follows:
\begin{enumerate}
    \item a constructor named \textit{new} which takes an object of the described above \textit{Key} class as argument,
    \item an \textit{encrypt} function which takes plaintext as a slice of bytes, cipher mode as an \textit{enum} and returns the ciphertext as a byte array,
    \item a \textit{decrypt} function that uses the same types of arguments as the \textit{decrypt} and converts from ciphertext to plaintext.
\end{enumerate}
The mentioned cipher mode is defined as an enumeration with two values for the \textit{ECB} (short for \textit{Electronic Code Book}) and the \textit{CBC} (short for \textit{Cipher Block Chaining}). These are just two out of several block cipher modes of operation that the \textit{AES} cipher is compatible with. The fuzzer can take 2 routes here. It can start with selecting the Key class or the \textit{Aes} one. Selecting the former will limit the fuzzing scope to only the \textit{Key} class, as its functions don't rely on other entities. However, this is not true for the cipher class. The constructor of \textit{Aes} class takes a key, which requires creating it first. In general, the fuzzer needs to support cross-references between classes.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Target API example.},label={lst:extarget}]
struct Key(Vec<u8>);

impl Key {
    pub fn new(key: &[u8]) -> Self;
    pub fn wrap(&self, other: &Key);
}

struct Aes(Key);

enum AesMode {
    ECB,
    CBC
}

impl Aes {
    pub fn new(key: Key) -> Self;
    pub fn encrypt(&self, data: &[u8], AesMode: mode) -> Vec<u8>;
    pub fn decrypt(&self, data: &[u8], AesMode: mode) -> Vec<u8>;
}
\end{lstlisting}
\end{minipage}

The simplified illustration of the fuzzer action can be seen in \ref{fig:fuzzscenario}. It shows that the execution has two main branches. The one starting with \textit{Key} class and the other with \textit{Aes}. As discussed before, the \textit{Key} class doesn't require any other entity, therefore it has far less possible options. On the other hand, the \textit{Aes} path recursively goes back to fuzzing \textit{Key} class as its object is required for the constructor of the cipher. One might think that fuzzing the \textit{Key} class just to provide an object is unnecessary, as calling the constructor will provide the required object. However, calling member functions on an object might modify the internal state of it. Therefore, invoking just the constructor will limit the exploration abilities of the fuzzer. This can then lead to limited ability in finding sophisticated bugs that require many conditions to trigger. Then the fuzzer chooses and calls appropriate member functions.

\tikzstyle{start} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!60]
\tikzstyle{api} = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=green!30]
\tikzstyle{call} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=yellow!30]
\tikzstyle{end} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=red!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{figure}[h!]
    \centering

    \scalebox{.75}{%
        \begin{tikzpicture}
            \node (start) [start] {Choose API to fuzz};
            \node (key) [api, below of=start, yshift=-1cm] { Choose to fuzz \textit{Key} API };
            \node (aes) [api, right of=key, xshift=5cm] { Choose to fuzz \textit{Aes} API };
    
            \node (keyctor) [call, below of=key, yshift=-1cm] { Call Key::new(...) };
            \node (wrap) [call, below of=keyctor, yshift=-1cm] { Call Key::wrap(constructed key) };
            \node (end1) [start,  below of=wrap, yshift=-1cm] { End };
    
            \node (keyctor2) [call, below of=aes, yshift=-1cm] { Call Key::new(...) };        
            \node (keymember) [call, below of=keyctor2, yshift=-1cm, text width=3cm] { Call some member functions on key };
            \node (aesctor) [call, below of=keymember, yshift=-1cm] { Call Aes::new(constructed key) };
            \node (dec) [decision, below of=aesctor, yshift=-3cm, text width=3cm, xshift=0cm] { Choose member function to call };
            \node (encrypt) [call, below of=dec, left of=dec, yshift=-3cm, xshift=-4cm] { Call Aes::encrypt(aes, ...) };
            \node (decrypt) [call, below of=dec, left of=dec, yshift=-3cm, xshift=1cm] { Call Aes::decrypt(aes, ...) };
            \node (end2) [start, below of=decrypt, yshift=-1cm] { End };
            
            \draw [arrow] (start) -- (key); 
            \draw [arrow] (start) -| (aes);
            \draw [arrow] (key) -- (keyctor);
            \draw [arrow] (keyctor) -- (wrap);
            \draw [arrow] (wrap) -- (end1);
            \draw [arrow] (aes) -- (keyctor2);
            \draw [arrow] (keyctor2) -- (keymember);
            \draw [arrow] (keymember) -- (aesctor);
            \draw [arrow] (aesctor) -- (dec);
            \draw [arrow] (dec) -| (encrypt);
            \draw [arrow] (dec) -- (decrypt);
            \draw [arrow] (encrypt) |- (end2);
            \draw [arrow] (decrypt) -- (end2);
        \end{tikzpicture}
    }
    
    \caption{Possible fuzzing scenario.}
    \label{fig:fuzzscenario}
\end{figure}

\subsubsection{Generating test cases from unit tests} \label{sec:testint}
Preparing a corpus before running the fuzzer is a good practice that can speed up the fuzzing process. Normally, gathering test cases isn't an issue when the target of fuzzing is, for example, an image viewer. In the case of fuzzing APIs, the test cases are decoded to function calls, which makes them harder to collect. Naturally, a good place to gather corpus is unit tests for the fuzzed target. The only issue left to solve is encoding back the function calls to fuzzer's binary test cases format. This task requires implementing a process that will operate backward to the test case decoder module.

\paragraph{Inverting expressions}
Rewriting all unit tests to fuzzer binary test cases by hand is highly repetitive and inefficient and therefore should be automated. Doing it manually would require creating a test case byte per byte which is similar to programming a processor directly using the machine code. To limit the modifications needed to be applied to the target code, it is best to hook the tested interface functions the test suite uses. This enables us to analyze the function's argument values. When we take the inspected value and combine it with the expression that was used to create it we can try to solve for the test case bytes. More on function tracing is provided later in the next section, as I will focus now on the invertibility of the designed target description. To check if this is possible we need to check if all expressions in the API description language are invertible. In mathematics, for an inverse function to exist the function needs to be a bijection. Unfortunately, not all the defined primitives meet this requirement. In detail, the invertibility of each such primitive is explained as follows:
\begin{itemize}
    \item \textit{\#U8, \#U16, \#U32} - those expressions are bijections as every number has a unique representation in computer memory, provided we don't change computer architecture which might change the endianess,
    \item \textit{\#Slice(length)} - this is simple to reverse as this expression holds a slice of the original test case, so it can be just concatenated to the test case,
    \item \textit{\#Api(name)} - this is just a mark which class will be fuzzed recursively and is therefore a compile-time known constant making it reversible,
    \item \textit{\#OneOf(option1, option2, ...)} - here each value from the list is associated with a number from a set containing natural numbers from 0 to count less one, as a result, the compiler can generate a series of conditional statements checking which value was encountered and emit the proper index,
    \item \textit{\#Str(length)} - since this is derived from the \textit{\#Slice(length)} macro, it can also be concatenated after converting the text to bytes,
    \item \textit{\#Mod(a, b)} - the inverse of $y = x \mod n$ is $x = y + k \cdot n$ $\forall k \in \mathbb{N}$, the easiest solution is that for $ k=0 $, so I decided to yield \textit{a} as the inverse of the modulo operation.
\end{itemize}
Naturally, to fully inverse an expression each of its arguments needs to be inverted first, as during the fuzzing process it will be decoded first. For example, while decoding the \textit{\#Slice(length)} primitive the expression passed as the length will be inverted first using the calculated length of the slice before it gets concatenated to the resulting test case. The same applies for the \textit{\#Mod(a, b)} whose inverse is the inverse of the expression passed as the \textit{a} parameter. Although all described primitives are inversible, only the first one is a bijection on its domain. The domains of the other expressions were implicitly restricted to make it bijective. Of course, this is just a formal requirement for a function to be invertible, and the fuzzer will work just fine even if it is not met. The only downside of omitting this requirement is the existence of many test cases that will be decoded to the same sequence of function calls. On the other hand, the inverse of a function call will yield only one encoding. Fortunately, genetic fuzzers will not promote the same encoding over the other equivalent, as it can't increase the coverage by finding a new path. 


\paragraph{Unit tests tracing design}
Tracing a function requires the ability to inspect each of the arguments' values as well as the return value. Ideally, we would like to prepend to the function's body some code that will perform parameter analysis just before the original function's body might tamper with them. In the end, the code should acquire and examine the return value. The most general way to catch the return value is to use the closure mechanism by wrapping the original function body in a lambda expression and invoking it. Then, the code may proceed with the examination of the return value and finish with actually returning it. The illustration of this concept is shown in listing \ref{lst:tracingdesign}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Unit tests tracing design.},label={lst:tracingdesign}]
fn some_function(argument1: type1, argument2: type2) -> return_type {
    inspect_argument1!(argument1);
    inspect_argument2!(argument2);

    let return_value = || { /* original funcion body */ }();

    inspect_return_value!(return_value);
    return return_value;
}
\end{lstlisting}
\end{minipage}

\paragraph{Example of unit test tracing}
In detail, the easiest way to trace a function is to create a \textit{proc macro} that will prepend the function body with parameter inspecting code and append the return value handler. Since neither the arguments nor the return value is changed, there is no need to alter the function's signature. The result of applying such macro to the \textit{Creds::login} function can be seen in listing \ref{lst:tcrev}. The first thing that catches the eye is the usage of the singleton \textit{TcAssembler}. This object implements all the required utilities to glue a test case byte per byte. It provides the opposite methods to the \textit{Buffer} class that is used to consume the test case during fuzzing. The traced function starts by calling the \textit{select\_api} function with the class identifier passed as argument. This is done to tell the fuzzer which class should be selected in the fuzzing algorithm. The second argument, here initialized by \textit{None} is the optional object identifier. Since this is the constructor and the object is yet to be created, this field is missing. The true significance of it will be described later in this chapter. Overall, this function call yields the class's numerical identifier in a place that the fuzzer will use to determine which class to fuzz. Next, since the \textit{Creds::login} is a constructor, the constructor identifier is added to the test case by calling the \textit{select\_ctor} with the function identifier passed as a parameter. Then follow the macros' invocation, which inverse each argument. These macros will be described later in the next paragraph. What remains is acquiring the return value by executing the original function's code in a closure and inspecting it. This ends the transformation done by the tracing macros. What is left to describe is generating the parameter and return values inspectors.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Example testcase reversing code.},label={lst:tcrev}]
pub fn login(user: String, password: String) -> Result<Self, Error> {
    TcAssembler::take()
        .select_api(Apis::Creds as u8, None)
        .select_ctor(encodings::__ctors_Creds::Creds_login as u8);
    __encode_Creds__Creds_login_arg_0__!(user);
    __encode_Creds__Creds_login_arg_1__!(password);
    let mut __ret__ = || {
        /*
            Original function code
        */
    }();
    __encode_Creds__Creds_login_epilogue__!(__ret__);
    __ret__
}
\end{lstlisting}
\end{minipage}


\paragraph{Arguments inspecting macros}
The macros used to inspect the arguments are created by the same compiler that is generating the actual fuzzer. It is done this way because the \textit{proc macro} implementing the compiler is the only entity that has the description of the target. Additionally, there are no established communication channels between different macro invocations. Of course, a macro can always store information in the operating system as it has access to the file system, but this is not officially supported and cannot be relied on. Moreover, the order in which macros are evaluated in the project is implementation-defined and might be unpredictable. For this reason, these macros are created along with the test case decoding algorithm. In detail, each of them will contain an appropriate sequence of calls to the \textit{TcAssembler} object that will inverse the argument values based on the supplied expressions. The macros required by the \textit{Creds::login} function are shown in listing \ref{lst:geninv}. It can be seen that the \textit{\_\_encode\_Creds\_\_Creds\_login\_arg\_0\_\_} macro has one parameter being a label. That argument holds the traced parameter value and will be used to inverse the expressions supplied in the target description. For clarity, let us recall that both of the arguments were initialized by the following expression \textit{\#Str(\#Mod(\#U8, 32))}. This directly translates to the shown function calls to the \textit{TcAssembler} object. Slicing from outside, the expression begins with a \textit{\#Str(length)}. This is inverted as the inverse of length, which is calculated as the actual string size, and the content of the text literal. Next, comes the \textit{\#Mod(a, b)} part, whose inverse evaluates to the inverse of \textit{a}. Finally, the inverse of \textit{\#U8} yields a single byte with the value of the text literal length. This can be seen in the referenced example. In line 4 the \textit{add\_byte} function is called to append the length of the text which is then followed by a call to \textit{add\_bytes} with the content of the string converted to a byte array. The description of the macro that inverts the second argument can be omitted, as in this case, it has the same body.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Generated macros which inverse the arguments.},label={lst:geninv}]
macro_rules! __encode_Creds__Creds_login_arg_0__ {
    ($label : ident) => {
        TcAssembler::take()
            .add_byte($label.len() as u8)
            .add_bytes($label.as_bytes());
    };
}
\end{lstlisting}
\end{minipage}

\paragraph{Inspection of the return value}
Inspection of the return value might seem unnecessary for creating the test case, as only function arguments are encoded in the test case. However, this proved to be necessary for the task of creating test cases from traced functions. Let us imagine that the unit test function created two objects of type \textit{Creds} which are then used to call some other \textit{APIs}. This situation shows a new, previously undescribed issue. Up to this point, there is no functionality in the design that allows for identifying the created objects. As a result, the fuzzing algorithm cannot select the proper object from the cache to call the member function on. For example, in languages such as \textit{Python} each object can be identified by its pointer which is returned by the built-in \textit{id()} function. Unfortunately, there is no similar mechanism in \textit{Rust}. For this reason, the objects need to have a field that can identify different instances. This additional field can be added through another \textit{proc macro} that is acting on the class definition itself. It is enough to add the field with two member functions, allowing to get and set the identifier. Now, distinguishing between objects is possible, so the only required thing to do is to set the \textit{id} value at the end of the constructor. This is where the return value inspection macro becomes handy. An example of the return value inspecting macro used in the constructor of the \textit{Creds} class is shown in listing \ref{lst:retvalinsp}. It can be seen that this macro uses a \textit{match} statement to check if the return value contains an error. In case, no error was encountered, the \textit{\_\_set\_id\_\_()} member function is called on the newly created object to set its identifier. This, beside the \textit{\_\_get\_id\_\_()}, is the specially added member function along with the hidden \textit{id} field itself. This identifier can later be used by the added tracing code to encode the correct identifier in the test case so that the fuzzer will take the correct object from the cache. The identification of the objects happens inside the \textit{select\_api} function of the \textit{TcAssembler} object. We previously said that the second argument is initialized to \textit{None} inside a constructor. Of course, a constructor creates the object, so there is no associated object. However, this is not the case in member functions, where the second argument of the \textit{select\_api} function is populated with the object's identifier. This then allows the fuzzer to select the proper object from the object cache.


\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust,caption={Return value inspecting macro.},label={lst:retvalinsp}]
macro_rules! __encode_Creds__Creds_login_epilogue__ {
    ($ret : ident) => {
        match &mut $ret {
            Ok(obj) => obj.__set_id__(),
            Err(_) => {}
        }
    };
}
\end{lstlisting}
\end{minipage}

